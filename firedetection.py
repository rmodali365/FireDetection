# -*- coding: utf-8 -*-
"""firedetection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pn0p5Lh5hqqPz2Do432u-EPtDDX8NljS
"""

from google.colab import drive
drive.mount('/content/drive/')
import tensorflow as tf
from tensorflow import keras
import numpy as np
import os
from tensorflow.keras.optimizers import RMSprop
import zipfile
from os import path, getcwd, chdir
from tensorflow.keras.preprocessing.image import ImageDataGenerator

train_fire_dir=os.path.join("/content/drive/My Drive/fireornofire/fire")
train_nofire_dir=os.path.join("/content/drive/My Drive/fireornofire/nofire")
print('total training fire images:', len(os.listdir(train_fire_dir)))
print('total training no fire images:', len(os.listdir(train_nofire_dir)))

train_nofire_names=os.listdir(train_nofire_dir)
print(train_nofire_names[:5])

train_fire_names=os.listdir(train_fire_dir)
print(train_fire_names[:5])

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self,epochs,logs={}):
    if (logs.get("accuracy")>=0.95):
      print("you have reached desired accuracy")
      self.model.stop_training=True
callbacks=myCallback()

model= tf.keras.models.Sequential([
    tf.keras.layers.Conv2D(16,(3,3),activation="relu",input_shape=(300,300,3)),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(16,(3,3),activation="relu"),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(16,(3,3),activation="relu"),#
    tf.keras.layers.MaxPooling2D(2,2),#
    tf.keras.layers.Conv2D(32,(3,3),activation="relu"),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Conv2D(32,(3,3),activation="relu"),#
    tf.keras.layers.MaxPooling2D(2,2),#
    tf.keras.layers.Conv2D(64,(3,3),activation="relu"),
    tf.keras.layers.MaxPooling2D(2,2),
    tf.keras.layers.Flatten(),
    tf.keras.layers.Dense(512,activation="relu"),
    #tf.keras.layers.Dense(256,activation="relu"),#
    tf.keras.layers.Dense(256,activation="relu"),
    tf.keras.layers.Dense(128,activation="relu"),
    tf.keras.layers.Dense(128,activation="relu"),
    tf.keras.layers.Dense(64,activation="relu"),
    tf.keras.layers.Dense(64,activation="relu"),
    tf.keras.layers.Dense(32,activation="relu"),
    #tf.keras.layers.Dense(32,activation="relu"),#
    tf.keras.layers.Dense(1,activation="sigmoid")

])

model.summary()

model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

train_datagen = ImageDataGenerator(rescale=1/255)
validation_datagen = ImageDataGenerator(rescale=1/255)
train_generator = train_datagen.flow_from_directory(
        '/content/drive/My Drive/fireornofire',  # This is the source directory for training images
        target_size=(300, 300),  # All images will be resized to 300x300
        batch_size=128,
        # Since we use binary_crossentropy loss, we need binary labels
        class_mode='binary')
validation_generator= validation_datagen.flow_from_directory(
    '/content/drive/My Drive/validationfire',
    target_size=(300, 300),
    batch_size=10,
    class_mode='binary')

history = model.fit(
      train_generator,
      steps_per_epoch=8,  
      epochs=30,
      callbacks=[callbacks],
      verbose=1,
      validation_data=validation_generator,
      validation_steps=10)
model.save('model.fire')

from google.colab import files
from keras.preprocessing import image

uploaded = files.upload()

for fn in uploaded.keys():
 
  # predicting images
  path = '/content/' + fn
  img = image.load_img(path, target_size=(300, 300))
  x = image.img_to_array(img)
  x = np.expand_dims(x, axis=0)

  images = np.vstack([x])
  classes = model.predict(images, batch_size=10)
  print(classes[0])
  if classes[0]>0.5:
    print(fn + " is not a fire")
  else:
    print(fn + " is a fire")

from keras.models import load_model
from keras.preprocessing import image
img_width, img_height = 300, 300

# load the model we saved
model = load_model('model.fire')
model.compile(loss='binary_crossentropy',
              optimizer='adam',
              metrics=['accuracy'])

# predicting images
img = image.load_img('fire.jpg', target_size=(img_width, img_height))
x = image.img_to_array(img)
x = np.expand_dims(x, axis=0)

images = np.vstack([x])
classes = model.predict_classes(images, batch_size=10)
print (classes)

# predicting multiple images at once
img = image.load_img('fire.jpg', target_size=(img_width, img_height))
y = image.img_to_array(img)
y = np.expand_dims(y, axis=0)

# pass the list of multiple images np.vstack()
images = np.vstack([x, y])
classes = model.predict_classes(images, batch_size=10)

# print the classes, the images belong to
print (classes)
print (classes[0])
print (classes[0][0])

"""110 fire images
157 normal images
"""